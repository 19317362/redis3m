\href{https://travis-ci.org/luca3m/redis3m}{\tt !\mbox{[}Build Status\mbox{]}(https\-://travis-\/ci.\-org/luca3m/redis3m.\-png?branch=master)}

A C++ \href{http://redis.io}{\tt Redis} driver, born to bring my experience using Redis and C++ on a opensource library.

\subsubsection*{Main goals}


\begin{DoxyEnumerate}
\item Provide a simple and efficient wrapper of \href{http://github.com/redis/hiredis}{\tt hiredis}, with C++ facilities like memory management
\item A connection pooling system, with support for high availability using sentinel
\item A set of useful patterns ready to use and composable with other code. For example \href{http://luca3m.me/2013/12/03/redis-scheduler.html}{\tt scheduler}, \href{http://github.com/soveran/ohm}{\tt orm}, counters or message queueing
\end{DoxyEnumerate}

\subsubsection*{Dependencies}

redis3m requires hiredis and boost libraries.

\subsubsection*{Install}

First step install all required dependencies, on a Debian system you can use\-:

```bash sudo apt-\/get install libmsgpack-\/dev libboost-\/thread-\/dev libboost-\/date-\/time-\/dev libboost-\/test-\/dev libboost-\/filesystem-\/dev libboost-\/system-\/dev libhiredis-\/dev cmake build-\/essential ```

Then checkout the code and compile it ```bash git clone \href{https://github.com/luca3m/redis3m}{\tt https\-://github.\-com/luca3m/redis3m} cd redis3m cmake make sudo make install ```

\subsubsection*{Documentation}

See \href{https://github.com/luca3m/redis3m/tree/master/examples}{\tt examples} directory for some examples, you can compile them with\-:

```bash g++ $<$example.\-cpp$>$ \$(pkg-\/config --cflags --libs redis3m) -\/o $<$example.\-bin$>$ ```

As reference you can read \href{https://github.com/luca3m/redis3m/tree/master/include}{\tt include} files, they are pretty simple and some of them are already documented with Doxygen.

\subsubsection*{Versioning}

This project uses \href{http://semver.org}{\tt semantic versioning}. In short words versions are named X.\-Y\mbox{[}.Z\mbox{]}. Changing X means break A\-P\-I changes, Y means new features without breaking old code, Z means bug fixing. 